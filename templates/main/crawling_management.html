<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í¬ë¡¤ë§ ê´€ë¦¬ - Healthtant</title>
</head>
<body>
    <h1>ì¿ íŒ¡ í¬ë¡¤ë§ ê´€ë¦¬</h1>
    
    <!-- í¬ë¡¤ë§ í†µê³„ -->
    <div>
        <h2>í¬ë¡¤ë§ í˜„í™©</h2>
        <div id="crawlingStats">
            <div>ì´ ê°€ê²© ì •ë³´: <span id="totalPrices">-</span></div>
            <div>ëŒ€ê¸° ì¤‘: <span id="pendingPrices">-</span></div>
            <div>í¬ë¡¤ë§ ì¤‘: <span id="inProgressPrices">-</span></div>
            <div>ì„±ê³µ: <span id="successPrices">-</span></div>
            <div>ì‹¤íŒ¨: <span id="failedPrices">-</span></div>
            <div>ì œí’ˆ ì—†ìŒ: <span id="notFoundPrices">-</span></div>
        </div>
        <button onclick="loadCrawlingStats()">í†µê³„ ìƒˆë¡œê³ ì¹¨</button>
    </div>
    
    <!-- í¬ë¡¤ë§ ì œì–´ -->
    <div class="crawling-controls">
        <div class="input-group">
            <label for="foodIds">ì‹í’ˆ ID ëª©ë¡ (ì‰¼í‘œë¡œ êµ¬ë¶„):</label>
            <input type="text" id="foodIds" placeholder="F20240001, F20240002, F20240003">
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="headless" checked>
            <label for="headless">ë°±ê·¸ë¼ìš´ë“œ ì‹¤í–‰ (ë¸Œë¼ìš°ì € ì°½ ìˆ¨ê¹€)</label>
        </div>
        
        <div class="button-group">
            <button onclick="startCrawling()" class="btn btn-primary">í¬ë¡¤ë§ ì‹œì‘</button>
            <button onclick="startAllCrawling()" class="btn btn-success">ì „ì²´ í¬ë¡¤ë§ ì‹œì‘</button>
            <button onclick="retryFailedCrawling()" class="btn btn-warning">ì‹¤íŒ¨ í•­ëª© ì¬ì‹œë„</button>
        </div>
    </div>
    
    <!-- ìµœê·¼ í¬ë¡¤ë§ ê²°ê³¼ -->
    <div>
        <h2>ìµœê·¼ í¬ë¡¤ë§ ê²°ê³¼</h2>
        <div id="recentResults">ë¡œë”© ì¤‘...</div>
    </div>
    
    <!-- í¬ë¡¤ë§ ë¡œê·¸ -->
    <div>
        <h2>í¬ë¡¤ë§ ë¡œê·¸</h2>
        <div id="crawlingLog" style="height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; background-color: #f9f9f9;">
            í¬ë¡¤ë§ ë¡œê·¸ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...
        </div>
    </div>
    
    <script>
        // í˜ì´ì§€ ë¡œë“œ ì‹œ í†µê³„ ë¡œë“œ
        document.addEventListener('DOMContentLoaded', function() {
            loadCrawlingStats();
            loadRecentResults();
        });
        
        // í¬ë¡¤ë§ í†µê³„ ë¡œë“œ
        async function loadCrawlingStats() {
            try {
                const response = await fetch('/api/crawling-status/');
                const data = await response.json();
                
                if (data.success) {
                    const stats = data.data.statistics;
                    document.getElementById('totalPrices').textContent = stats.total;
                    document.getElementById('pendingPrices').textContent = stats.pending;
                    document.getElementById('inProgressPrices').textContent = stats.in_progress;
                    document.getElementById('successPrices').textContent = stats.success;
                    document.getElementById('failedPrices').textContent = stats.failed;
                    document.getElementById('notFoundPrices').textContent = stats.not_found;
                    
                    addLog('í†µê³„ ì •ë³´ë¥¼ ìƒˆë¡œê³ ì¹¨í–ˆìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                console.error('í†µê³„ ë¡œë“œ ì‹¤íŒ¨:', error);
                addLog('í†µê³„ ë¡œë“œ ì‹¤íŒ¨: ' + error.message);
            }
        }
        
        // ìµœê·¼ í¬ë¡¤ë§ ê²°ê³¼ ë¡œë“œ
        async function loadRecentResults() {
            try {
                const response = await fetch('/api/crawling-status/');
                const data = await response.json();
                
                if (data.success) {
                    const recent = data.data.recent_crawled;
                    const container = document.getElementById('recentResults');
                    
                    if (recent.length === 0) {
                        container.innerHTML = '<p>ì•„ì§ í¬ë¡¤ë§ëœ ì œí’ˆì´ ì—†ìŠµë‹ˆë‹¤.</p>';
                        return;
                    }
                    
                    let html = '<table border="1" style="width: 100%; border-collapse: collapse;">';
                    html += '<tr><th>ì œí’ˆëª…</th><th>íšŒì‚¬</th><th>ê°€ê²©</th><th>ìƒíƒœ</th><th>í¬ë¡¤ë§ ì‹œê°„</th></tr>';
                    
                    recent.forEach(item => {
                        const statusColor = getStatusColor(item.crawling_status);
                        const crawledTime = item.crawled_at ? new Date(item.crawled_at).toLocaleString() : '-';
                        
                        html += `<tr>
                            <td>${item.food_name}</td>
                            <td>${item.company_name}</td>
                            <td>${item.price ? item.price.toLocaleString() + 'ì›' : '-'}</td>
                            <td style="color: ${statusColor};">${getStatusText(item.crawling_status)}</td>
                            <td>${crawledTime}</td>
                        </tr>`;
                    });
                    
                    html += '</table>';
                    container.innerHTML = html;
                }
            } catch (error) {
                console.error('ìµœê·¼ ê²°ê³¼ ë¡œë“œ ì‹¤íŒ¨:', error);
                addLog('ìµœê·¼ ê²°ê³¼ ë¡œë“œ ì‹¤íŒ¨: ' + error.message);
            }
        }
        
        // í¬ë¡¤ë§ ì‹œì‘
        async function startCrawling() {
            const foodIdsText = document.getElementById('foodIds').value.trim();
            const headless = document.getElementById('headless').checked;
            
            if (!foodIdsText) {
                addLog('âŒ í¬ë¡¤ë§í•  ì‹í’ˆ IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
                return;
            }
            
            const foodIds = foodIdsText.split(',').map(id => id.trim()).filter(id => id);
            
            try {
                addLog('ğŸš€ í¬ë¡¤ë§ì„ ì‹œì‘í•©ë‹ˆë‹¤...', 'info');
                
                const response = await fetch('/api/start-crawling/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        food_ids: foodIds,
                        headless: headless
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    addLog(`âœ… ${result.message}`, 'success');
                    addLog(`ğŸ“Š ì´ ${result.data.total_foods}ê°œ ì‹í’ˆ í¬ë¡¤ë§ ì‹œì‘ë¨`, 'info');
                    
                    // í†µê³„ ìƒˆë¡œê³ ì¹¨
                    loadCrawlingStats();
                    loadRecentResults();
                } else {
                    addLog(`âŒ ${result.message}`, 'error');
                }
                
            } catch (error) {
                addLog(`âŒ í¬ë¡¤ë§ ì‹œì‘ ì‹¤íŒ¨: ${error.message}`, 'error');
            }
        }
        
        async function startAllCrawling() {
            const headless = document.getElementById('headless').checked;
            
            try {
                addLog('ğŸš€ ì „ì²´ í¬ë¡¤ë§ì„ ì‹œì‘í•©ë‹ˆë‹¤...', 'info');
                addLog('âš ï¸ Food DBì˜ ëª¨ë“  ì‹í’ˆì„ í¬ë¡¤ë§í•©ë‹ˆë‹¤. ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.', 'warning');
                
                const response = await fetch('/api/start-all-crawling/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        headless: headless
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    addLog(`âœ… ${result.message}`, 'success');
                    addLog(`ğŸ“Š ì´ ${result.data.total_foods}ê°œ ì‹í’ˆ ì „ì²´ í¬ë¡¤ë§ ì‹œì‘ë¨`, 'info');
                    
                    // í†µê³„ ìƒˆë¡œê³ ì¹¨
                    loadCrawlingStats();
                    loadRecentResults();
                } else {
                    addLog(`âŒ ${result.message}`, 'error');
                }
                
            } catch (error) {
                addLog(`âŒ ì „ì²´ í¬ë¡¤ë§ ì‹œì‘ ì‹¤íŒ¨: ${error.message}`, 'error');
            }
        }
        
        // ì‹¤íŒ¨ í•­ëª© ì¬ì‹œë„
        async function retryFailedCrawling() {
            try {
                addLog('ì‹¤íŒ¨ í•­ëª© ì¬ì‹œë„ ì‹œì‘...');
                
                const response = await fetch('/api/retry-crawling/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    addLog(`âœ… ${result.message}`);
                    
                    // 5ì´ˆ í›„ í†µê³„ ìƒˆë¡œê³ ì¹¨
                    setTimeout(() => {
                        loadCrawlingStats();
                        loadRecentResults();
                    }, 5000);
                } else {
                    addLog(`âŒ ì¬ì‹œë„ ì‹¤íŒ¨: ${result.message}`);
                }
                
            } catch (error) {
                console.error('ì¬ì‹œë„ ì‹¤íŒ¨:', error);
                addLog('âŒ ì¬ì‹œë„ ì‹¤íŒ¨: ' + error.message);
            }
        }
        
        // ë¡œê·¸ ì¶”ê°€
        function addLog(message, type = 'info') {
            const logElement = document.getElementById('crawlingLog');
            const timestamp = new Date().toLocaleTimeString();
            let logEntry = `[${timestamp}] ${message}\n`;
            
            switch (type) {
                case 'success':
                    logEntry = `[${timestamp}] âœ… ${message}\n`;
                    break;
                case 'error':
                    logEntry = `[${timestamp}] âŒ ${message}\n`;
                    break;
                case 'warning':
                    logEntry = `[${timestamp}] âš ï¸ ${message}\n`;
                    break;
                case 'info':
                    logEntry = `[${timestamp}] â„¹ï¸ ${message}\n`;
                    break;
                default:
                    logEntry = `[${timestamp}] ${message}\n`;
            }
            
            logElement.textContent += logEntry;
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        // ìƒíƒœë³„ ìƒ‰ìƒ ë°˜í™˜
        function getStatusColor(status) {
            switch (status) {
                case 'success': return '#28a745';
                case 'failed': return '#dc3545';
                case 'not_found': return '#ffc107';
                case 'in_progress': return '#17a2b8';
                case 'pending': return '#6c757d';
                default: return '#000000';
            }
        }
        
        // ìƒíƒœë³„ í…ìŠ¤íŠ¸ ë°˜í™˜
        function getStatusText(status) {
            switch (status) {
                case 'success': return 'ì„±ê³µ';
                case 'failed': return 'ì‹¤íŒ¨';
                case 'not_found': return 'ì œí’ˆ ì—†ìŒ';
                case 'in_progress': return 'ì§„í–‰ ì¤‘';
                case 'pending': return 'ëŒ€ê¸° ì¤‘';
                default: return status;
            }
        }
        
        // ìë™ ìƒˆë¡œê³ ì¹¨ (30ì´ˆë§ˆë‹¤)
        setInterval(() => {
            loadCrawlingStats();
            loadRecentResults();
        }, 30000);

        // CSRF Token ê°€ì ¸ì˜¤ê¸°
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    // Does this cookie string begin with the name we want?
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
    </script>
</body>
</html>
